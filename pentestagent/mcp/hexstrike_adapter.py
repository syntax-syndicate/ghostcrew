"""Adapter to manage a vendored HexStrike MCP server.

This adapter provides a simple programmatic API to start/stop the vendored
HexStrike server (expected under ``third_party/hexstrike``) and to perform a
health check before returning control to the caller.

The adapter is intentionally lightweight (no Docker) and uses an async
subprocess so the server can run in the background while the TUI/runtime
operates.
"""

import asyncio
import os
import shutil
import signal
import time
from pathlib import Path
from typing import Optional

try:
    import aiohttp
except Exception:
    aiohttp = None


from ..workspaces.utils import get_loot_file


class HexstrikeAdapter:
    """Manage a vendored HexStrike server under `third_party/hexstrike`.

    Usage:
        adapter = HexstrikeAdapter()
        await adapter.start()
        # ... use MCPManager to connect to the server
        await adapter.stop()
    """

    def __init__(
        self,
        host: str = "127.0.0.1",
        port: int = 8888,
        python_cmd: str = "python3",
        server_script: Optional[Path] = None,
        cwd: Optional[Path] = None,
        env: Optional[dict] = None,
    ) -> None:
        self.host = host
        self.port = int(port)
        self.python_cmd = python_cmd
        self.server_script = (
            server_script
            or Path("third_party/hexstrike/hexstrike_server.py")
        )
        self.cwd = cwd or Path.cwd()
        self.env = {**os.environ, **(env or {})}

        self._process: Optional[asyncio.subprocess.Process] = None
        self._reader_task: Optional[asyncio.Task] = None

    def _build_command(self):
        return [self.python_cmd, str(self.server_script), "--port", str(self.port)]

    async def start(self, background: bool = True, timeout: int = 30) -> bool:
        """Start the vendored HexStrike server.

        Returns True if the server started and passed health check within
        `timeout` seconds.
        """
        if not self.server_script.exists():
            raise FileNotFoundError(
                f"HexStrike server script not found at {self.server_script}."
            )

        if self._process and self._process.returncode is None:
            return await self.health_check(timeout=1)

        cmd = self._build_command()

        # Resolve python command if possible
        resolved = shutil.which(self.python_cmd) or self.python_cmd

        self._process = await asyncio.create_subprocess_exec(
            resolved,
            *cmd[1:],
            cwd=str(self.cwd),
            env=self.env,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.STDOUT,
            start_new_session=True,
        )

        # Log PID for debugging and management
        try:
            pid = getattr(self._process, "pid", None)
            if pid:
                log_file = get_loot_file("artifacts/hexstrike.log")
                with log_file.open("a") as fh:
                    fh.write(f"[HexstrikeAdapter] started pid={pid}\n")
        except Exception as e:
            import logging

            logging.getLogger(__name__).exception("Failed to write hexstrike start PID to log: %s", e)
            try:
                from ..interface.notifier import notify

                notify("warning", f"Failed to write hexstrike PID to log: {e}")
            except Exception:
                logging.getLogger(__name__).exception("Failed to notify operator about hexstrike PID log failure")

        # Start a background reader task to capture logs
        loop = asyncio.get_running_loop()
        self._reader_task = loop.create_task(self._capture_output())

        # Wait for health check
        try:
            return await self.health_check(timeout=timeout)
        except Exception:
            return False

    async def _capture_output(self) -> None:
        """Capture stdout/stderr from the server and append to the log file."""
        if not self._process or not self._process.stdout:
            return

        try:
            log_file = get_loot_file("artifacts/hexstrike.log")
            with log_file.open("ab") as fh:
                while True:
                    line = await self._process.stdout.readline()
                    if not line:
                        break
                    fh.write(line)
                    fh.flush()
        except asyncio.CancelledError:
            return
        except Exception as e:
            import logging

            logging.getLogger(__name__).exception("Error capturing hexstrike output: %s", e)
            try:
                from ..interface.notifier import notify

                notify("warning", f"HexStrike log capture failed: {e}")
            except Exception:
                logging.getLogger(__name__).exception("Failed to notify operator about hexstrike log capture failure")

    async def stop(self, timeout: int = 5) -> None:
        """Stop the server process gracefully."""
        proc = self._process
        if not proc:
            return

        try:
            proc.terminate()
            await asyncio.wait_for(proc.wait(), timeout=timeout)
        except asyncio.TimeoutError:
            try:
                proc.kill()
            except Exception as e:
                import logging

                logging.getLogger(__name__).exception("Failed to kill hexstrike after timeout: %s", e)
                try:
                    from ..interface.notifier import notify

                    notify("warning", f"Failed to kill hexstrike after timeout: {e}")
                except Exception:
                    logging.getLogger(__name__).exception("Failed to notify operator about hexstrike kill failure")
        except Exception as e:
            import logging

            logging.getLogger(__name__).exception("Error stopping hexstrike process: %s", e)
            try:
                from ..interface.notifier import notify

                notify("warning", f"Error stopping hexstrike process: {e}")
            except Exception:
                logging.getLogger(__name__).exception("Failed to notify operator about hexstrike stop error")

        self._process = None

        if self._reader_task and not self._reader_task.done():
            self._reader_task.cancel()
            try:
                await self._reader_task
                except Exception as e:
                    import logging

                    logging.getLogger(__name__).exception("Error awaiting hexstrike reader task: %s", e)
                    try:
                        from ..interface.notifier import notify

                        notify("warning", f"Error awaiting hexstrike reader task: {e}")
                    except Exception:
                        logging.getLogger(__name__).exception("Failed to notify operator about hexstrike reader await failure")

    def stop_sync(self, timeout: int = 5) -> None:
        """Synchronous stop helper for use during process-exit cleanup.

        This forcefully terminates the underlying subprocess PID if the
        async event loop is no longer available.
        """
        proc = self._process
        if not proc:
            return

        # Try to terminate gracefully first
        try:
            pid = getattr(proc, "pid", None)
            if pid:
                # Kill the whole process group if possible (handles children)
                try:
                    pgid = os.getpgid(pid)
                    os.killpg(pgid, signal.SIGTERM)
                except Exception:
                    try:
                        os.kill(pid, signal.SIGTERM)
                    except Exception:
                        import logging

                        logging.getLogger(__name__).exception("Failed to SIGTERM hexstrike pid: %s", pid)
                        try:
                            from ..interface.notifier import notify

                            notify("warning", f"Failed to SIGTERM hexstrike pid {pid}")
                        except Exception:
                            logging.getLogger(__name__).exception("Failed to notify operator about hexstrike SIGTERM failure")

                # wait briefly for process to exit
                end = time.time() + float(timeout)
                while time.time() < end:
                    ret = getattr(proc, "returncode", None)
                    if ret is not None:
                        break
                    time.sleep(0.1)

                # If still running, force kill the process group
                try:
                    pgid = os.getpgid(pid)
                    os.killpg(pgid, signal.SIGKILL)
                except Exception:
                    try:
                        os.kill(pid, signal.SIGKILL)
                    except Exception:
                        import logging

                        logging.getLogger(__name__).exception("Failed to SIGKILL hexstrike pid: %s", pid)
                        try:
                            from ..interface.notifier import notify

                            notify("warning", f"Failed to SIGKILL hexstrike pid {pid}")
                        except Exception:
                            logging.getLogger(__name__).exception("Failed to notify operator about hexstrike SIGKILL failure")
        except Exception as e:
            import logging

            logging.getLogger(__name__).exception("Error during hexstrike stop_sync cleanup: %s", e)
            try:
                from ..interface.notifier import notify

                notify("warning", f"Error during hexstrike stop_sync cleanup: {e}")
            except Exception:
                logging.getLogger(__name__).exception("Failed to notify operator about hexstrike stop_sync cleanup error")

    def __del__(self):
        try:
            self.stop_sync()
        except Exception as e:
            import logging

            logging.getLogger(__name__).exception("Exception during HexstrikeAdapter.__del__: %s", e)
            try:
                from ..interface.notifier import notify

                notify("warning", f"Error during HexstrikeAdapter cleanup: {e}")
            except Exception:
                logging.getLogger(__name__).exception("Failed to notify operator about hexstrike __del__ error")
        # Clear references
        try:
            self._process = None
        except Exception as e:
            import logging

            logging.getLogger(__name__).exception("Failed to clear HexstrikeAdapter process reference: %s", e)
            try:
                from ..interface.notifier import notify

                notify("warning", f"Failed to clear hexstrike process reference: {e}")
            except Exception:
                logging.getLogger(__name__).exception("Failed to notify operator about hexstrike process-clear failure")

    async def health_check(self, timeout: int = 5) -> bool:
        """Check the server health endpoint. Returns True if healthy."""
        url = f"http://{self.host}:{self.port}/health"

        if aiohttp:
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(url, timeout=timeout) as resp:
                        return resp.status == 200
            except Exception as e:
                import logging

                logging.getLogger(__name__).exception("HexstrikeAdapter health_check (aiohttp) failed: %s", e)
                try:
                    from ..interface.notifier import notify

                    notify("warning", f"HexStrike health check failed: {e}")
                except Exception:
                    logging.getLogger(__name__).exception("Failed to notify operator about hexstrike health check failure")
                return False

        # Fallback: synchronous urllib in thread
        import urllib.request

        def _check():
            try:
                with urllib.request.urlopen(url, timeout=timeout) as r:
                    return r.status == 200
            except Exception as e:
                import logging

                logging.getLogger(__name__).exception("HexstrikeAdapter health_check (urllib) failed: %s", e)
                try:
                    from ..interface.notifier import notify

                    notify("warning", f"HexStrike health check failed: {e}")
                except Exception:
                    logging.getLogger(__name__).exception("Failed to notify operator about hexstrike urllib health check failure")
                return False

        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(None, _check)

    def is_running(self) -> bool:
        return self._process is not None and self._process.returncode is None


__all__ = ["HexstrikeAdapter"]
